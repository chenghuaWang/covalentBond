/**
 * @file luaEngine.hpp
 * @author chenghua Wang (chenghua.wang.edu@gmail.com)
 * @brief  A lua engine for execute all c++ embedding in struct.
 * A warper of lua JIT engine.
 * @version 0.1
 * @date 2022-10-27
 *
 * @copyright Copyright (c) 2022
 *
 */
#ifndef __SERVER_LUA_ENGINE_HPP_
#define __SERVER_LUA_ENGINE_HPP_

#include <string>
#ifdef _WIN32
#if _MSC_VER > 1000
#pragma once
#endif
#endif  //! _WIN32

#if defined(__unix__) && defined(__clang__)
#pragma once
#endif  //! defined(__unix__) && defined(__clang__)

#include "../../pch.hpp"

#if CB_USE_SOL == false
//! make compiled in C ABI, and all libs is installed to system path.
extern "C" {
#include <lua.h>
#include <luajit.h>
#include <lauxlib.h>
#include <lualib.h>
}
#include <any>
#else
#define SOL_ALL_SAFETIES_ON 1
#include <sol/sol.hpp>
#include <any>
#endif

#define __TYPE_REINTERPRET_(x, y)                               \
  switch (y.m_type) {                                           \
    case __baseType::Int: x = y.as<cbInt>().get(); break;       \
    case __baseType::Float: x = y.as<cbFloat>().get(); break;   \
    case __baseType::String: x = y.as<cbString>().get(); break; \
  }

#define __LUA_IN_SCRIPT_AUTO_GEN_(x) \
  "\
This file is auto generated by covalent bound lua-preprocess\n\
The Entry point is:\n\n\
    function CBMain()\n\
    end\n\n\
This Operator has (##x) values to calculate\n\n\
For Example, if you has (x=3) values to perform this operate\n\
atom_1.a = 2;\n\
atom_1.b = \"foo\";\n\
atom_2.c = atom_1.c;\n\
atom_3.a = \"foo\";\n\n\
Also, you don't need to return any values. You are required to\n\
pass all values as the way below:\n\
ans.a = 1;\n\
ans.b = \"foo\"\n\n\n\
"

/**
 * @brief Only support int/float/string yet.
 * You can enlarge this data type set.
 *
 */
enum class __baseType : uint8_t {
  Int = 0,
  Float = 1,
  String = 2,
};

/**
 * @brief The basic object for all type record class to inherited.
 *
 */
struct __baseObj {
  __baseObj(const __baseType& type, const std::string& name) : m_type(type), m_name(name) {}

  template<typename T>
  T& as() {
    return static_cast<T>(*this);
  }

  __baseType m_type = __baseType::Int;
  std::string m_name = "";
};

struct cbInt : public __baseObj {
  cbInt(const std::string& key, int32_t value) : __baseObj(__baseType::Int, key), m_data(value) {}

  int32_t get() { return std::any_cast<int32_t>(m_data); }

 public:
  std::any m_data;
};

struct cbFloat : public __baseObj {
  cbFloat(const std::string& key, float value) : __baseObj(__baseType::Float, key), m_data(value) {}

  float get() { return std::any_cast<float>(m_data); }

 public:
  std::any m_data;
};

struct cbString : public __baseObj {
  cbString(const std::string& key, const std::string& value)
      : __baseObj(__baseType::String, key), m_data(value) {}

  std::string& get() { return std::any_cast<std::string&>(m_data); }

 public:
  std::any m_data;
};

/**
 * @brief This class will generate the type reminder. Due to the logical of
 * control the data on the stack. The value name are not open to users when
 * they try to write lua script, and the entry point is predefined. So we
 * need this function to generate all pre-script files, first.
 *
 * @param nums
 * @param rhs
 * @param outs
 * @return std::string
 */
std::string luaTypeReminder(int32_t nums, std::vector<std::vector<__baseObj>>& rhs,
                            const std::vector<__baseObj>& outs);

extern "C" {
// reference https://github.com/ThePhD/sol2 's doc
/**
 * @brief
 *
 */
class luaJitThread {
 public:
  luaJitThread() : m_lua_handle(sol::state()) { m_lua_handle.open_libraries(); }

  void loadScript2Mem(const std::string& rhs);
  void loadScriptFromFile(const std::string& file_path);

  sol::state& self();
  void execMain(int32_t nums, std::vector<std::vector<__baseObj>>& rhs,
                std::vector<__baseObj>& outs);

 private:
  std::string m_script;
  sol::state m_lua_handle = nullptr;
};
}

#endif  //! __SERVER_LUA_ENGINE_HPP_
